# ====================================================================================
# PEG Grammar for 'some language, idk anymore'
# ====================================================================================

# ---- Top-level statement - This is the entry point ----

test
    <- plpgsql_statement+

program
    <- Spacing postgresql_statement EndOfFile

postgresql_statement
    <- (create_function / create_procedure) SEP


# ------------------------------------------------------------------------------------
# CREATE FUNCTION Statement
# ------------------------------------------------------------------------------------

create_function
    <-  CREATE (OR REPLACE)? FUNCTION function_name create_function_arglist
        (RETURNS SETOF? type 
        / RETURNS TABLE column_list)?
        function_options

function_name 
    <- name

create_function_arglist 
    <- OPEN (create_function_arg (COMMA create_function_arg)*)? CLOSE

create_function_arg 
    <- argmode? argname? argtype ((EQUALS / DEFAULT) default_expr)?

argmode 
    <- IN / OUT/ INOUT / VARIADIC

argname 
    <- name 

argtype 
    <- type 

default_expr 
    <- expression

column_list 
    <- OPEN column (COMMA column)* CLOSE

column 
    <- column_name column_type

column_name 
    <- name

column_type
    <- type

function_options
    <- function_option+

function_option
    <- (LANGUAGE language 
    / transform_option
    / WINDOW 
    / volatility_option
    / leakproof_option
    / nullinput_option
    / security_option
    / parallel_option
    / COST execution_cost
    / ROWS result_rows
    / SUPPORT support_function
    / set_option
    / AS definition
    )

transform_option
    <- TRANSFORM transform_list 

transform_list 
    <- transformation (COMMA transformation)*

transformation
    <- FOR TYPE type 

volatility_option
    <- IMMUTABLE / STABLE / VOLATILE

leakproof_option
    <- NOT? LEAKPROOF 

nullinput_option
    <- CALLED ON NULL INPUT / RETURNS NULL ON NULL INPUT / STRICT

security_option 
    <- EXTERNAL? SECURITY INVOKER / EXTERNAL? SECURITY DEFINER

parallel_option
    <- PARALLEL (UNSAFE / RESTRICTED / SAFE)

set_option 
    <- SET configuration_parameter (TO expression / EQUALS expression / FROM CURRENT)

execution_cost
    <- positive_real # TODO: zu 'expression' blackboxen (nervt aber beim testen)

result_rows 
    <- positive_real # TODO: zu 'expression' blackboxen (nervt aber beim testen)

support_function
    <- function_name

configuration_parameter
    <- parameter_name

parameter_name 
    <- identifier

definition 
    <- block_start plpgsql_outer_block block_end 

block_start
    <- DOUBLE_DOLLAR
    
block_end
    <- DOUBLE_DOLLAR


# ------------------------------------------------------------------------------------
# CREATE PROCEDURE Statement
# ------------------------------------------------------------------------------------

create_procedure
    <-  CREATE (OR REPLACE)? PROCEDURE procedure_name create_function_arglist
        procedure_options

procedure_name 
    <- name

procedure_options
    <- procedure_option+

procedure_option
    <- transform_option
    / security_option
    / set_option
    / AS definition


# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# PL/pgSQL
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

plpgsql_outer_block
    <- shift_label? declare_section? BEGIN plpgsql_statement+ exception? END label? SEP? 

plpgsql_inner_block
    <- shift_label? declare_section? BEGIN plpgsql_statement+ exception? END label? SEP

shift_label 
    <- LSHIFT name RSHIFT   # TODO: note that <<   blubb   >> will have the name 'blubb' without spaces

label 
    <- name

declare_section
    <- DECLARE declaration+

declaration
    <- variable CONSTANT? type collation? (NOT NULL)? declaration_assignment? SEP

collation 
    <- COLLATE collation_name 

collation_name
    <- name

declaration_assignment 
    <- (DEFAULT / assign) expression

assign 
    <- ASSIGN / EQUALS

exception 
    <- EXCEPTION exception_handler+

exception_handler
    <- WHEN exception_conditions THEN plpgsql_statement+

exception_conditions
    <- exception_condition (OR exception_condition)*

exception_condition
    <- any                              # TODO: implement our exception conditions or use postgresql's?
    # found here: https://www.postgresql.org/docs/18/errcodes-appendix.html (Appendix A)

# ------------------------------------------------------------------------------------
# PL/pgSQL Statements
# ------------------------------------------------------------------------------------

plpgsql_statement
    <- sql_command
    / assignment_statement
    / execute_statement
    / null_statement
    / return_statement 
    / call_statement
    / loop_statement
    / if_statement 
    / case_statement
    / searched_case_statement
    / continue_statement
    / while_statement
    / for_statement 
    / for_query_statement
    / foreach_statment
    

sql_command
    <- blackbox             # TODO: let duckdb handle this

assignment_statement
    <- variable assign expression SEP 

execute_statement
    <- EXECUTE commandstring (INTO STRICT? variables)? (USING expressions)? SEP
    
commandstring
    <- expression             # TODO: Special expression that returns a string of type text

expressions 
    <- expression (COMMA expression)*

null_statement 
    <- NULL SEP

return_statement 
    <- RETURN NEXT expression SEP
    / RETURN QUERY (sql_command / execute_statement) SEP
    / RETURN expression SEP

call_statement
    <- CALL (function_name / procedure_name) function_arglist SEP 

function_arglist 
    <- OPEN (variable REQUALS function_arg (COMMA variable REQUALS function_arg)*)? CLOSE
    / OPEN (function_arg (COMMA function_arg)*)? CLOSE

function_arg
    <- expression

if_statement
    <- IF expression THEN plpgsql_statement+ 
    (ELSIF expression THEN plpgsql_statement+)*
    (ELSE plpgsql_statement+)?
    END IF SEP

case_statement
    <- CASE expression 
    (WHEN expressions THEN plpgsql_statement+)+
    (ELSE plpgsql_statement+)?
    END CASE SEP
     
searched_case_statement
    <- CASE 
    (WHEN boolexpr THEN plpgsql_statement+)+
    (ELSE plpgsql_statement+)?
    END CASE SEP

boolexpr
    <- expression      # TODO: Special expression that returns a boolean

loop_statement
    <- shift_label? LOOP plpgsql_statement+ END LOOP label? SEP

continue_statement
    <- CONTINUE label? (WHEN boolexpr)? SEP

while_statement
    <- shift_label? WHILE boolexpr LOOP plpgsql_statement+ END LOOP label? SEP

for_statement
    <- shift_label? FOR name IN REVERSE? expression DOUBLE_DOT expression 
    LOOP plpgsql_statement+ END LOOP label? SEP

for_query_statement
    <- shift_label? FOR variables IN (sql_command / execute_statement)
    LOOP plpgsql_statement+ END LOOP label? SEP
    
foreach_statment
    <- shift_label? FOREACH variable (SLICE number)? IN ARRAY expression 
    LOOP plpgsql_statement+ END LOOP label? SEP



# ------------------------------------------------------------------------------------
# Identifiers, Types and Expressions
# ------------------------------------------------------------------------------------

variable 
    <- identifier

variables
    <- variable (COMMA variable)*

name
    <- identifier

identifier 
    <- (quoted_id / id) Spacing

quoted_id
    <- '"' ( '""' / (!'"' .) )* '"'

id  <- (!keyword) idStart idChars* 

idStart
    <- [a-zA-Z_]

idChars 
    <- [a-zA-Z0-9_]

positive_real 
    <- [0-9]+ ('.' [0-9]*)? Spacing  

expression 
    <- NULL / any     # TODO: let duckdb handle this    

type 
    <- any   # TODO: let duckdb handle this

any 
    <- identifier / number / String 

number 
    <- [0-9]+ ('.' [0-9]+)? Spacing

String 
    <- '\'' ( '\'\' ' / (!'\'' .) )* '\'' Spacing


# ------------------------------------------------------------------------------------
# Keywords
# ------------------------------------------------------------------------------------

keyword <- CREATE / PROCEDURE / LANGUAGE / AS / SECURITY 
        / INVOKER / DEFINER / SET / CALL / IN / OUT 
        / INOUT / BEGIN / END / DECLARE / FUNCTION / OR / REPLACE
        / RETURN / RETURNS / TABLE / VARIADIC / TRANSFORM / FOR / TYPE
        / WINDOW / IMMUTABLE / STABLE / VOLATILE / NOT
        / LEAKPROOF / CALLED / ON / NULL / INPUT / STRICT 
        / EXTERNAL / PARALLEL / COST / ROWS / SUPPORT
        / TO / FROM / CURRENT / UNSAFE / RESTRICTED / SAFE / DEFAULT 
        / CONSTANT / PLPGSQL / COLLATE / EXECUTE / INTO / USING / NEXT / QUERY
        / SETOF / IF / THEN / ELSE / ELSIF / CASE / WHEN / LOOP / CONTINUE 
        / WHILE / REVERSE / BY / FOREACH / ARRAY


CREATE      <- [Cc] [Rr] [Ee] [Aa] [Tt] [Ee] keysep
PROCEDURE   <- [Pp] [Rr] [Oo] [Cc] [Ee] [Dd] [Uu] [Rr] [Ee] keysep
LANGUAGE    <- [Ll] [Aa] [Nn] [Gg] [Uu] [Aa] [Gg] [Ee] keysep
AS          <- [Aa] [Ss] keysep
SECURITY    <- [Ss] [Ee] [Cc] [Uu] [Rr] [Ii] [Tt] [Yy] keysep
INVOKER     <- [Ii] [Nn] [Vv] [Oo] [Kk] [Ee] [Rr] keysep
DEFINER     <- [Dd] [Ee] [Ff] [Ii] [Nn] [Ee] [Rr] keysep
SET         <- [Ss] [Ee] [Tt] keysep
CALL        <- [Cc] [Aa] [Ll] [Ll] keysep
IN          <- [Ii] [Nn] keysep
OUT         <- [Oo] [Uu] [Tt] keysep
INOUT       <- [Ii] [Nn] [Oo] [Uu] [Tt] keysep
BEGIN       <- [Bb] [Ee] [Gg] [Ii] [Nn] keysep
END         <- [Ee] [Nn] [Dd] keysep
DECLARE     <- [Dd] [Ee] [Cc] [Ll] [Aa] [Rr] [Ee] keysep
FUNCTION    <- [Ff] [Uu] [Nn] [Cc] [Tt] [Ii] [Oo] [Nn] keysep
OR          <- [Oo] [Rr] keysep
REPLACE     <- [Rr] [Ee] [Pp] [Ll] [Aa] [Cc] [Ee] keysep
RETURN     <- [Rr] [Ee] [Tt] [Uu] [Rr] [Nn] keysep
RETURNS     <- [Rr] [Ee] [Tt] [Uu] [Rr] [Nn] [Ss] keysep
TABLE       <- [Tt] [Aa] [Bb] [Ll] [Ee] keysep
VARIADIC    <- [Vv] [Aa] [Rr] [Ii] [Aa] [Dd] [Ii] [Cc] keysep
TRANSFORM   <- [Tt] [Rr] [Aa] [Nn] [Ss] [Ff] [Oo] [Rr] [Mm] keysep
FOR         <- [Ff] [Oo] [Rr] keysep
TYPE        <- [Tt] [Yy] [Pp] [Ee] keysep
WINDOW      <- [Ww] [Ii] [Nn] [Dd] [Oo] [Ww] keysep
IMMUTABLE   <- [Ii] [Mm] [Mm] [Uu] [Tt] [Aa] [Bb] [Ll] [Ee] keysep
STABLE      <- [Ss] [Tt] [Aa] [Bb] [Ll] [Ee] keysep
VOLATILE    <- [Vv] [Oo] [Ll] [Aa] [Tt] [Ii] [Ll] [Ee] keysep
NOT         <- [Nn] [Oo] [Tt] keysep
LEAKPROOF   <- [Ll] [Ee] [Aa] [Kk] [Pp] [Rr] [Oo] [Oo] [Ff] keysep
CALLED      <- [Cc] [Aa] [Ll] [Ll] [Ee] [Dd] keysep
ON          <- [Oo] [Nn] keysep
NULL        <- [Nn] [Uu] [Ll] [Ll] keysep
INPUT       <- [Ii] [Nn] [Pp] [Uu] [Tt] keysep
STRICT      <- [Ss] [Tt] [Rr] [Ii] [Cc] [Tt] keysep
EXTERNAL    <- [Ee] [Xx] [Tt] [Ee] [Rr] [Nn] [Aa] [Ll] keysep
PARALLEL    <- [Pp] [Aa] [Rr] [Aa] [Ll] [Ll] [Ee] [Ll] keysep
COST        <- [Cc] [Oo] [Ss] [Tt] keysep
ROWS        <- [Rr] [Oo] [Ww] [Ss] keysep
SUPPORT     <- [Ss] [Uu] [Pp] [Pp] [Oo] [Rr] [Tt] keysep
TO          <- [Tt] [Oo] keysep
FROM        <- [Ff] [Rr] [Oo] [Mm] keysep
CURRENT     <- [Cc] [Uu] [Rr] [Rr] [Ee] [Nn] [Tt] keysep
UNSAFE      <- [Uu] [Nn] [Ss] [Aa] [Ff] [Ee] keysep
RESTRICTED  <- [Rr] [Ee] [Ss] [Tt] [Rr] [Ii] [Cc] [Tt] [Ee] [Dd] keysep
SAFE        <- [Ss] [Aa] [Ff] [Ee] keysep
DEFAULT     <- [Dd] [Ee] [Ff] [Aa] [Uu] [Ll] [Tt] keysep
CONSTANT    <- [Cc] [Oo] [Nn] [Ss] [Tt] [Aa] [Nn] [Tt] keysep
PLPGSQL     <- [Pp] [Ll] [Pp] [Gg] [Ss] [Qq] [Ll] keysep
COLLATE     <- [Cc] [Oo] [Ll] [Ll] [Aa] [Tt] [Ee] keysep
EXECUTE     <- [Ee] [Xx] [Ee] [Cc] [Uu] [Tt] [Ee] keysep
INTO        <- [Ii] [Nn] [Tt] [Oo] keysep
USING       <- [Uu] [Ss] [Ii] [Nn] [Gg] keysep
NEXT        <- [Nn] [Ee] [Xx] [Tt] keysep
QUERY       <- [Qq] [Uu] [Ee] [Rr] [Yy] keysep
SETOF       <- [Ss] [Ee] [Tt] [Oo] [Ff] keysep
IF          <- [Ii] [Ff] keysep
THEN        <- [Tt] [Hh] [Ee] [Nn] keysep
ELSE        <- [Ee] [Ll] [Ss] [Ee] keysep
ELSIF       <- [Ee] [Ll] [Ss] [Ii] [Ff] keysep
CASE        <- [Cc] [Aa] [Ss] [Ee] keysep
WHEN        <- [Ww] [Hh] [Ee] [Nn] keysep
LOOP        <- [Ll] [Oo] [Oo] [Pp] keysep
CONTINUE    <- [Cc] [Oo] [Nn] [Tt] [Ii] [Nn] [Uu] [Ee] keysep
WHILE       <- [Ww] [Hh] [Ii] [Ll] [Ee] keysep
REVERSE     <- [Rr] [Ee] [Vv] [Ee] [Rr] [Ss] [Ee] keysep
BY          <- [Bb] [Yy] keysep
FOREACH     <- [Ff] [Oo] [Rr] [Ee] [Aa] [Cc] [Hh] keysep
ARRAY       <- [Aa] [Rr] [Rr] [Aa] [Yy] keysep
SLICE       <- [Ss] [Ll] [Ii] [Cc] [Ee] keysep
EXCEPTION   <- [Ee] [Xx] [Cc] [Ee] [Pp] [Tt] [Ii] [Oo] [Nn] keysep

language 
    <- PLPGSQL
    / 'other potential language'    # TODO: do we have other potential languages?


# ------------------------------------------------------------------------------------
# Meta Keywords
# ------------------------------------------------------------------------------------

keysep 
    <- !idChars Spacing

SEP     <- ';' Spacing
OPEN    <- '(' Spacing
CLOSE   <- ')' Spacing 
COMMA   <- ',' Spacing
DOLLAR  <- '$' Spacing
DOUBLE_DOLLAR 
        <- '$$' Spacing
ASSIGN  <- ':=' Spacing
EQUALS  <- '=' Spacing
LSHIFT  <- '<<' Spacing
RSHIFT  <- '>>' Spacing
REQUALS <- '=>' Spacing
DOUBLE_DOT
        <- '..' Spacing


# ------------------------------------------------------------------------------------
# Whitespace, Comments and Aux
# ------------------------------------------------------------------------------------

Spacing 
    <- (Space / Comment / EndOfLine)*

Space 
    <- ' ' 
    / '\t'

Comment 
    <- '--' ((!EndOfLine) .)* (EndOfLine / EndOfFile)
    / '/*' (!'*/' .)* '*/'

EndOfLine 
    <- '\r\n'
    / '\n'
    / '\r'

EndOfFile
    <- !.

blackbox 
    <- DOLLAR (!DOLLAR .)* DOLLAR Spacing







